/*------------------------------------------------------------------------------
/		Copyright (C) サークル煌明	All Rights Reserved.
/			MessageLayerADV - FadeCh機能追加
/ 
追加
defaulthchcorrect		// hchの中心を合わせるための補正値
/-----------------------------------------------------------------------------*/
@if(__MESSAGELAYERADV_DEFINED__==0)
@set(__MESSAGELAYERADV_DEFINED__=1)

var __flag_ChGradRecter_OBJECT_DEFINED__ = false;
Scripts.execStorage("FadeChLayer.tjs");

class MessageLayerADV extends MessageLayer {
	var hankakuPitch = 0;		// 半角の字間

	var fadeChLayers = [];
	var processedfadeChLayers = [];

	var currentCh = 0;	// 現在最終状態に居ない Ch 数
	var movingCh = 0;	// 現在フェード中の Ch 数
	var cl;				// 現在processCh/putGraphが扱っているfadeChレイヤ

	var ch4Fade = true, defaultCh4Fade = true;
	var chfadetime = 400, defaultChfadetime = 400;

	var hchCorrect = 0;			// hchの中心を合わせるための補正値
	var defaultHchCorrect = 0;

	var defaultEdgeExtent = edgeExtent; // 袋文字のふとさ
	var defaultEdgeEmphasis = edgeEmphasis; // 袋文字の強調度
	var defaultShadowOffsetX = shadowOffsetX; // 影のオフセット
	var defaultShadowOffsetY = shadowOffsetY; // 影のオフセット

	// ルビ
	var r_DefaultFace = "user"; // デフォルトのフォント
	var r_UserFace = "ＭＳ Ｐ明朝"; // ユーザの選んだフォント
	var r_DefaultBold = true; // デフォルトでボールドで描画するか
	var r_Bold; // ボールドで描画するか

	var r_DefaultShadowColor = 0x000000; // デフォルトの影の色
	var r_ShadowColor; // 影の色
	var r_DefaultEdgeColor = 0x0080ff; // デフォルトの縁取りの色
	var r_EdgeColor; // 縁取りの色
	var r_DefaultChColor = 0xffffff; // デフォルトの文字色
	var r_ChColor; // 文字色

	// ふらふら
	var chSlant = 0;
	var defaultChSlant = 0;
	// ロット。回転
	var chRot = 0;
	var defaultChRot = 0;
	// 回転ループ
	var chRotMode = "none", chRotLoopC, chRotRound;
	var defaultChRotMode = "none", defaultChRotLoopC, defaultChRotRound;
	// グラデーション
	var chGradMode = "none";	// ループ。モード
	var chGradLoopC;			// カウンタ
	var chGradation = [], chGradationArray = [], chGradRound;	// グラデーションの状態と、その差分
	var defaultChGradMode = "none";
	var defaultChGradLoopC;
	var defaultChGradation = [], defaultChGradationArray = [], defaultChGradRound;
	var tmpchloopCounter = 0;
	// ふらふらループ x y
	var chSxMode = "none", chSxLoopC, chSx, chSxRound;
	var defaultChSxMode = "none", defaultChSxLoopC, defaultChSx, defaultChSxRound;
	var chSyMode = "none", chSyLoopC, chSy, chSyRound;
	var defaultChSyMode = "none", defaultChSyLoopC, defaultChSy, defaultChSyRound;

	// 回転しながら出現
	var chRotMoveMode = "none", chRotMoveRound;
	var defaultChRotMoveMode = "none", defaultChRotMoveRound;
	// ふらふらしながら出現 x y
	var chSxMoveMode = "none", chSxMove;
	var defaultChSxMoveMode = "none", defaultChSxMove;
	var chSyMoveMode = "none", chSyMove;
	var defaultChSyMoveMode = "none", defaultChSyMove;

	var cx, cy;	// get_cx, get_cy
	var currentRubyAlign = "e"; // 次の文字に対するルビの割り付け方法

	var rubyAlign;
	var defaultRubyAlign = "e";
	// 親文字字間拡張機能 (ルビ長が親文字より長い際に親文字の字間を広げる機能)
	var rubyOverflow;
	var currentRubyOverflow;	// 次のchの字間拡張サイズ
	var defaultRubyOverflow;

	var id__ = 0;

	var canChGrad = false;	// 文字グラデーションが可能か
	var chGradObj = void;

	function MessageLayerADV(owner, parent, name, id, do_config) {
		super.MessageLayer(...);
		if(do_config) {
			r_UserFace = userFace;
			r_DefaultFace = userFace;
		}

		if(__flag_ChGradRecter_OBJECT_DEFINED__==1) {
			chGradObj = new ChGradRecter(kag, name+"_ChGradRecter");
			kag.addPlugin(chGradObj);
			canChGrad = true;
//			dm("__flag_ChGradRecter_OBJECT_DEFINED__  " + kag.currentWithBack);
		}
	}

	function finalize() {
		forEachFadeChFinish();
		super.finalize(...);
	}

/*--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-
/ @文字列をフェード表示
/=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--*/
	function clearLayer() {
		super.clearLayer(...);
		forEachFadeChClear();
	}

	function fixLineLayer() {
		super.fixLineLayer(...);
		forEachFadeChFloat();
	}

	function reline() {
		// ページを越える場合は true, 越えないで改行できる場合は false
		var n = super.reline(...);
		if(n) forEachFadeChFloat();
		
		return n;
	}

	function reline2() {
	}

	function initLineLayer() {
		// lineLayer の初期化
		with(lineLayer) {
			resetLineSize();
			lineLayerLinks.count = 0;
			lineLayerOriginX = x;
			lineLayerOriginY = y;

			if(!vertical) {
				.imageWidth = imageWidth + 8;
			} else {
				.imageHeight = imageHeight + 8;
			}
			.setSizeToImageSize();
			changeLineSize(/*forceresize=*/true);
			lineLayerLength = 0;
			lineLayerPos = 0;
		//	.visible = false;
			.face = dfAuto;
			var lliw = .imageWidth;
			var llih = .imageHeight;
			.fillRect(0, 0, lliw, llih, 0);	// 完全透明に
			.face = dfProvince;
			.fillRect(0, 0, lliw, llih, 0);	// 領域をクリア
			.face = dfAuto;
		}
	}

	function getLineLayerBaseLine() {
		// 文字表示用のベースラインを計算して返す
		// 横書きの場合は文字の下端部分、
		// 縦書きの場合は文字の中央線
		if(!vertical)
			return -getLineLayerTopOffset() + lineSpacing + lineSize;
		else
			// 縦書き
			// 中央線(レイヤ左端からの位置)
			return (lineSize>>1);
	}

	function getLineLayerLeftOffset() {
		// 行描画用レイヤ内での左オフセットを取得
		if(!vertical) {
			if(align == -1)
				return 0;
			else if(align == 0)
				return ((imageWidth - marginR - marginL - lineLayerLength)>>1);
			else if(align == 1)
				return imageWidth - marginR - marginL - lineLayerLength;
		} else {
			return -lineSize - lineSpacing;
		}
	}

	function getLineLayerTopOffset() {
		// 行描画用レイヤ内での上オフセットを取得
		if(!vertical) {
			return -(lineLayer.imageHeight - lineSize - lineSpacing);
		} else {
			if(align == -1)
				return 0;
			else if(align == 0)
				return ((imageHeight - marginB - marginT - lineLayerLength)>>1);
			else if(align == 1)
				return imageHeight - marginB - marginT - lineLayerLength;
			return 0;
		}
	}

	function changeLineSize(forceresize = false) {
		// 行サイズが変更されたときに行描画用レイヤのサイズを変更するために
		// 呼ばれる
		var ll = lineLayer;
		if(inLink!=-1) endLinkLine();
		decideSizeChange();

		var oldWidth = ll.imageWidth;
		var oldHeight = ll.imageHeight;

		var newlinesize = (fontSize>lineSize) ? fontSize : lineSize;
		var newlinelayersize = newlinesize
			 + ((rubySize+rubyOffset>lineSpacing) ? rubySize+rubyOffset : lineSpacing) + 8;

		if(!vertical) {
			// 横書きの場合
			if(forceresize || ll.imageHeight<newlinelayersize) {
				// 行間拡張
				lineSize = newlinesize;
				ll.imageHeight = newlinelayersize;
				ll.setSizeToImageSize();
				lineLayerBase = getLineLayerBaseLine();
				// 内容移動
				if(!forceresize) {
					var newHeight = ll.imageHeight;
					var d = ll.imageHeight - oldHeight;
					ll.face = dfAuto;
					ll.copyRect(0, d, ll, 0, 0, oldWidth, newHeight);
					ll.fillRect(0, 0, oldWidth, d, 0);

					ll.face = dfProvince;
					ll.copyRect(0, d, ll, 0, 0, oldWidth, newHeight);
					ll.colorRect(0, 0, oldWidth, d, 0);
					ll.face = dfAuto;

/*__OVERRIDE__*/	forEachFadeChMove(0, d);
				}
				for(var i = 0; i<lineLayerLinks.count; i++) {
					var n = lineLayerLinks[i].number;
					var l = lineLayerLinks[i].line;
					links[n].y[l] += ll.imageHeight - oldHeight;
				}
				// 位置移動 
				ll.setPos(lineLayerOriginX + getLineLayerLeftOffset(),
							lineLayerOriginY + getLineLayerTopOffset());
			}
		} else {
			// 縦書きの場合
			if(forceresize || oldWidth < newlinelayersize) {
				// 行間拡張
				lineSize = newlinesize;
				var oldbase = lineLayerBase;
				ll.imageWidth = newlinelayersize;
				ll.setSizeToImageSize();
				lineLayerBase = getLineLayerBaseLine();
				// 内容移動
				if(!forceresize) {
					var newWidth = ll.imageWidth;
					var d = lineLayerBase - oldbase;
					ll.face = dfAuto;
					ll.copyRect(d, 0, ll, 0, 0, newWidth, oldHeight);
					ll.fillRect(0, 0, d, oldHeight, 0);
					ll.fillRect(oldWidth, 0, newWidth - (d + oldWidth), oldHeight, 0);

					ll.face = dfProvince;
					ll.copyRect(d, 0, ll, 0, 0, newWidth, oldHeight);
					ll.colorRect(0, 0, d, oldHeight, 0);
					ll.colorRect(d+oldWidth, 0, newWidth - (d + oldWidth), oldHeight, 0);
					ll.face = dfAuto;

/*__OVERRIDE__*/	forEachFadeChMove(-d, 0);
				}
				for(var i = 0; i < lineLayerLinks.count; i++) {
					var n = lineLayerLinks[i].number;
					var l = lineLayerLinks[i].line;
					links[n].x[l] += lineLayerBase - oldbase;
				}
				// 位置移動 
				ll.setPos(lineLayerOriginX + getLineLayerLeftOffset(),
							lineLayerOriginY + getLineLayerTopOffset());
			}
		}
	}

	function adjustAlign() {
		var x = lineLayerOriginX + getLineLayerLeftOffset() - lineLayer.left;
		var y = lineLayerOriginY + getLineLayerTopOffset() - lineLayer.top;
		forEachFadeChMove(x, y);
		lineLayer.setPos(lineLayerOriginX + getLineLayerLeftOffset(),
			lineLayerOriginY + getLineLayerTopOffset());
	}


	function setRuby(text, align, overflow) {
		// 次の文字に対するルビを設定する
		currentRuby = text;
		currentRubyAlign = align!==void ? align : rubyAlign;
		currentRubyOverflow = overflow!==void ? overflow : rubyOverflow;
	}

	function processCh(ch) {
		changeLineSize() if sizeChanged;

		var ll = lineLayer;
		var llfont = ll.font;
		var c_w = llfont.getTextWidth(ch);
		var c_h = llfont.getTextHeight(ch);

		// 複数文字描画時の改行処理：2文字目以降の長さの伸びを考慮する
		var mch = c_w-llfont.getTextWidth(ch[0]);

		// 改行処理
		if((vertical ? y+mch>=relinexpos : x+mch>=relinexpos ) && autoReturn) {
			if(( (lastDrawnCh=="" || wwLeading.indexOf(lastDrawnCh)==-1) && wwFollowing.indexOf(ch)==-1)
			 || (lastDrawnCh!="" && wwFollowingWeak.indexOf(lastDrawnCh)!=-1 && wwFollowingWeak.indexOf(ch)!=-1)) {
				if(reline()) return autoReturn;
			} else if(vertical ? ( y+mch>imageHeight ) : (x+mch>imageWidth)) {
				if(reline()) return autoReturn;
			}
		}

		var inlink = inLink != -1;
		beginLinkLine() if inlink;

	// スキップ入り
		if(processChnInF && currentCh) { forEachFadeChFinish(); }

		cl = getFadeChLayer();	// フェード用レイヤ
		set_chSR(cl);

		with(cl) {
			if(currentRuby != "") {
				.setRuby(currentRuby, currentRubyAlign);
				currentRuby = "";	// セットしたからもう要らない
			}

			var in_x, in_y, dr_x, dr_y, _width, _height;
			if(vertical) {
				in_x = set_cx(lineLayerBase - (c_h>>1)); in_y = lineLayerPos;
				dr_x = fontSize; dr_y = set_cy(0);
				_width = fontSize + rubySize + rubyOffset;
				_height = c_w;
			} else {
				in_x = lineLayerPos; in_y = 0;
				dr_x = set_cx(0); dr_y = set_cy(lineLayerBase - fontSize);
				_width = c_w;
				_height = ll.imageHeight;
			}
			.initChLayer(in_x, in_y, _width, _height);
	//		.fillRect(lineLayerBase, 0, 1, .height, 0xFFFFFFFF);

			if(edge) {
				.expandLayer(edgeExtent, edgeExtent);
				.drawText(dr_x, dr_y, ch, get_chColor(), 255, antialiased, 
					edgeEmphasis, edgeColor, edgeExtent, 0, 0);
			} else if(shadow) {
		//		shadowOffsetX=-10, shadowOffsetY=-10;	// テスト

				.expandLayer(shadowOffsetX, shadowOffsetY);
				.drawText(dr_x, dr_y, ch, get_chColor(), 255, antialiased, 
					255, shadowColor, 0, shadowOffsetX, shadowOffsetY);
			} else {
				.drawText(dr_x, dr_y, ch, get_chColor(), 255, antialiased);
			}

			// ※ルビ長が親文字より長い際に、親文字の字間を広げる機能 (FadeChLayer)
			if(.ruby!="") {
				c_w += .textExpandLength;
			}
		}

		ll.visible = true;

		if(inlink) {
			// ハイパーリンクでちゅー
			ll.face = dfProvince;
			if(!vertical)
				ll.fillRect(lineLayerPos, lineLayerBase - fontSize, c_w, fontSize, numLinks + 1);
			else
				ll.fillRect(lineLayerBase - (fontSize>>1), lineLayerPos, fontSize, c_w, numLinks + 1);

			// 領域画像も塗りつぶしてやる
			ll.face = dfAuto;
			linkFilled = true;
		}

		c_w += pitch;

		if(vertical) y += c_w; else x += c_w;

		lineLayerPos += c_w;
		lineLayerLength += c_w;

		lastDrawnCh = ch;

		adjustAlign() if(align >= 0);

		return false;
	}

	function putGraph(storage, key, ischar) {
		var ll = lineLayer;

		changeLineSize();

		if(inLink != -1) beginLinkLine();

		if(autoReturn && (vertical?(y>relinexpos):(x>relinexpos)) )
			if(reline()) return true;		// 改行位置に達している？


		cl = getFadeChLayer();
		set_chSR(cl);

		// テンポラリのレイヤを用意
		var lay = window.temporaryLayer;
		lay.fillRect(0, 0, lay.width, lay.height, 0x00000000);
		lay.loadImages(storage, key); // 画像読み込み
		var lw = lay.imageWidth, lh = lay.imageHeight;
		lay.setSizeToImageSize();

		var cw = vertical ? lh : lw;
		var in_x, in_y, dr_x, dr_y;

		if(currentRuby != "") {
			cl.setRuby(currentRuby, currentRubyAlign);
			currentRuby = "";	// セットしたからもう要らない
		}

		if(vertical) {
			in_x = set_cx(lineLayerBase - (lw>>1)), in_y = lineLayerPos;
			dr_x = cx; dr_y = set_cy(0);
			lw += rubySize + rubyOffset;
			if(fontSize > lw) lw += (fontSize-lw);
		} else {
			in_x = lineLayerPos; in_y = 0;
			dr_x = set_cx(0); dr_y = set_cy(lineLayerBase - lh);
			lh += dr_y;
		}

		var e_s_color = edge?edgeColor:shadowColor;
		cl.initChLayer(in_x, in_y, lw, lh);
		var color = get_chColor();

		if(edge) {
			cl.expandLayer(edgeExtent, edgeExtent);
			cl.drawGraph(dr_x, dr_y, lay, color, ischar, true, false, edgeExtent, edgeColor, edgeEmphasis, 0, 0);
		} else if(shadow) {
			cl.expandLayer(shadowOffsetX, shadowOffsetY);
			cl.drawGraph(dr_x, dr_y, lay, color, ischar, false, true, 0, shadowColor, 255, shadowOffsetX, shadowOffsetY);
		} else {
			cl.drawGraph(dr_x, dr_y, lay, color, ischar, false, false);
		}

		// 描画おわり
		lastDrawnCh="";

		if(inLink!=-1) {
			// ハイパーリン クでちゅー
			lineLayer.face = dfProvince;
			if(vertical)
				lineLayer.fillRect(lineLayerBase - (fontSize>>1), lineLayerPos,
					fontSize, cw, numLinks+1);
			else
				lineLayer.fillRect(lineLayerPos, lineLayerBase - fontSize,
					cw, fontSize, numLinks+1);
			face = dfAuto;
			lineLayer.face = dfBoth;
			// 領域画像も塗りつぶしてやる
			linkFilled=true;
		}

		if(vertical) { y+=cw; } else { x+=cw; }
		lineLayerPos += cw;
		lineLayerLength += cw;  

		lineLayer.visible = true;

		adjustAlign() if(align >= 0);

		return false;
	}

	function putHorizonCh(text, expand = false) {
		// 縦中横を描画する
		if(!vertical) throw new Exception("縦書きモードでないと使用できません");

		// フォントを設定し直す
		var ll = lineLayer;
		var lf = ll.font;
		var orgfont = lf.face;
		var organgle = lf.angle;

		var lff = orgfont.split('@', , true); // 先頭の @ マークを取り除く
		lf.face = (string)lff[-1];
		lf.angle = 0;

		// 描画する文字の横幅を取得
		var c_w = lf.getTextWidth(text);
		var c_h = lf.getTextHeight(text);

		// リンク中の場合はリンクを開始
		if(inLink != -1) beginLinkLine();

		// 改行/改ページ処理
		var repage = false;
		// 改行位置に達している？
		if(autoReturn && y > relinexpos) repage = reline();
		if(repage) {
			// 戻る前にフォントをもとにもどす
			lf.face = orgfont;
			lf.angle = organgle;
			return true; // 文字は描画しない
		}

			// はみ出るときの拡張
		if(c_w > lineSize) {
			if(expand) {
// TODO : はみ出しても行間拡張しない幅を設定できるようにする
// 		  左右に行間の半分。
				// 自動行間拡張が有効なら、行をまるごとずらす
				lineSize = c_w; // 拡張
				changeLineSize();
			}
		}

		// 描画
		with(cl = getFadeChLayer()) {
			set_chSR(cl);
			if(currentRuby != "") {
				.setRuby(currentRuby, currentRubyAlign);
				currentRuby = "";	// セットしたからもう要らない
			}

			var in_x = set_cx(lineLayerBase - (fontSize>>1) + hchCorrect);
			var in_y = lineLayerPos;
			var in_w = fontSize+rubySize+rubyOffset;
			var in_h = c_h;

			var dr_x = (fontSize-c_w)\2;
			var dr_y = set_cy(0);

// TODO : shadow
// dm("initChLayer : " + in_x, in_y, in_w, in_h);

			.initChLayer(in_x, in_y, in_w, in_h);

			// はみ出るときの拡張
			if(dr_x < 0) {
				.expandLayer(-dr_x, 0);
			//	dr_x -= dr_x;
			}

//				in_y += edge?edgeExtent:0;
//				dr_x += edge?edgeExtent:0;

			if(edge) {
				.expandLayer(edgeExtent, edgeExtent);
				.drawHCHText(dr_x, dr_y, text, get_chColor(), 255, 
					antialiased, edgeEmphasis, edgeColor, edgeExtent, 0, 0);
			} else if(shadow) {
		//		shadowOffsetX=-10, shadowOffsetY=-10;	// テスト
				.expandLayer(shadowOffsetX, shadowOffsetY);
				.drawHCHText(dr_x, dr_y, text, get_chColor(), 255, 
					antialiased, 255, shadowColor, 0, shadowOffsetX, shadowOffsetY);
			} else {
				.drawHCHText(dr_x, dr_y, text, get_chColor(), 255, antialiased);
			}
		}
		cl.hch = false;	// 縦中横フラグ

		// 描画おわり
		lastDrawnCh="";

		// フォントを元に戻す
		lf.face = orgfont;
		lf.angle = organgle;

		// ハイパーリンクの処理
		if(inLink!=-1) {
			// ハイパーリンクでちゅー
			ll.face = dfProvince;
			ll.fillRect(lineLayerBase - (fontSize>>1), lineLayerPos,
				fontSize, c_w, numLinks+1);
			face = dfAuto;
			ll.face = dfAuto;
			linkFilled=true;
		}

		c_h += pitch;

		y += c_h;
		lineLayerPos += c_h;
		lineLayerLength += c_h;

		lastDrawnCh = text;

		ll.visible = true;

		// アラインの修正
		adjustAlign() if(align >= 0);

		// 戻る
		return false;
	}

	function getFadeChLayer() {
		var cl_ = fadeChLayers.pop();
		if(cl_ === void) { 
			cl_ = new FadeChLayer(window, this);
			cl_.__id = id__++;
		}

		cl_.copyCondition();
		processedfadeChLayers.add(cl_);
		currentCh++;

		if(currentCh != processedfadeChLayers.count)
			dm('Fatal ERROR : currentChの値にエラーが発生');

		return cl_;
	}

	function putFadeChLayer(cl_) {
	// chレイヤ を待機状態にする
		processedfadeChLayers.remove(cl_, false);
		fadeChLayers.add(cl_);
		currentCh--;

		if(!currentCh) { movingCh = 0; }
	}

	function addMovingCh() {
		movingCh++;
	}

	function stopMovingCh() {
		movingCh--;
		// すべて写されていたらトリガを引く
		if(!movingCh && !processChnInF) { kag.conductor.trigger("fadeCh"); }
	}

	function waitFinishCh(elm) {
		if(movingCh) {
			forEachFadeChFloat();
			return global.kag.waitTrigger( %[
					canskip : elm.canskip = elm.canskip!==void ? elm.canskip : true,
					name : "fadeCh",
					onskip : "kag.current.forEachFadeChFinish()"
				] );
		} else {
			return 0;
		}
	}

	function forEachFadeChMove(x, y) {
	// 改行していない chレイヤ を動かす
		var i = currentCh;
		while(i--) { with(processedfadeChLayers[i]) { .changedChLinePos(x, y) if !.floated; } }
	}

	function forEachFadeChFloat() {
	// すべての chレイヤ の改行フラグを立てる
	// より以前に登録されたレイヤが先に改行フラグが立つ。
	// float() は転写処理が行われたらtrueを返す
		for(var i=0;i<currentCh;i++) {
			with(processedfadeChLayers[i]) { if(!.floated) if(.float()) i--; }
		}
	}

	function forEachFadeChFinish() {
	// すべての chレイヤ を最終状態に持ち込む
	// より以前に登録されたレイヤが先に最終状態になる。
	// finishLayerMoving() は転写処理が行われたらtrueを返す
		for(var i=0;i<currentCh;i++) {
			with(processedfadeChLayers[i]) { if(.finishLayerMoving()) i--; }
		}
	}

	function forEachFadeChClear() {
	// すべての chレイヤ を、メッセージレイヤに内容を移すことなく待機状態に戻す
		while(currentCh) {
			processedfadeChLayers[-1].stopLayerMoving();
			processedfadeChLayers[-1].resetChLayer();
			putFadeChLayer(processedfadeChLayers[-1]);
		}
	}

	property processChnInF {
		getter() {
			// 演出をしていないならTrue、しているならFalse
			return (kag.skipMode >= 2 || kag.actualChSpeed < 10);
		}
	}

/*--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-
/ @レンダリングフォント
/=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--*/
	function mapPrerenderedFont(storage) {
		// レンダリング済みフォントを現在の操作対象のレイヤに選択
		// されているフォントにマッピングする
		current.decideSizeChange();
		current.font.mapPrerenderedFont(storage);
//		current.lineLayer.font.mapPrerenderedFont(storage);
	}

/*--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-
/ @トランジション
/=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--*/
	function beginTransition(elm) {
		super.beginTransition(elm, comp);
	}

	function assignComp() {
		super.assignComp();
		// compの方から持ってくる
		forEachFadeChClear();
		var i = comp.currentCh;
		while(i--) {
			var __ch = getFadeChLayer();
			__ch.assign(comp.processedfadeChLayers[i]);
		}
		movingCh = comp.movingCh;
		if(canChGrad) {
			chGradObj.assign(comp.chGradObj);
		}
	}

	function exchangeInfo()
	{
		super.exchangeInfo();

		chGradObj.pluginName <-> comp.chGradObj.pluginName;
	}


/*--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-
/ @文字エフェクト・周期的を追加
/=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--*/
	function get_chColor() {
		var ge = chColor;
		if(chGradMode=="none") return ge;	// モード指定無し

		if(chGradationArray[0] === void) {
			gradationX( parseColor2Array(chGradation), chGradRound, chGradationArray );
		}
		if(chGradMode=="grad") {	// グラデ
			ge = chGradationArray[chGradLoopC];
			if(chGradLoopC<chGradRound-1) {chGradLoopC++;} else {chGradLoopC = 0;}
		} else if(chGradMode=="gradloop") {	// グラデ・ループ
			ge = chGradationArray[chGradLoopC];
			if(chGradRound>0) {
				if(chGradLoopC<chGradRound-1) {chGradLoopC++;}else{chGradRound = -chGradRound;}
			} else { if(chGradLoopC>0) {chGradLoopC--;}else{chGradRound = -chGradRound;} }
		} else if(chGradMode=="gradrandom") {	// グラデ・ランダム
			ge = chGradationArray[ int(Math.floor(Math.random()*chGradRound)) ];
		}
		return ge;
	}

	function set_cx(_cx) {
		if(chSxMode=="sin") {	// サインカーブ
			if(chSxLoopC<chSxRound-1) {chSxLoopC++;} else { chSxLoopC = 0; }
			cl.setSlant(chSx*Math.sin(6.2831*chSxLoopC/chSxRound), 0);
		}
		// 出現
		if(chSxMoveMode=="random") {
			cl.setSlantMove(chSxMove*Math.random(), 0);
		} else if(chSxMoveMode=="valuerandom") {
			cl.setSlantMove(chSxMove*Math.random()*(Math.random()>0.5?1:-1), 0);
		} else if(chSxMoveMode=="value") {
			cl.setSlantMove((int)chSxMove, 0);
		}
		cx = _cx;
		return cx;
	}

	function set_cy(_cy) {
		if(chSyMode=="sin") {	// サイン
			if(chSyLoopC<chSyRound-1) {chSyLoopC++;} else { chSyLoopC = 0; }
			cl.setSlant( 0, chSy*Math.sin(6.2831*chSyLoopC/chSyRound) );
		}
		if(chSyMoveMode=="random") {
			cl.setSlantMove(0,chSyMove*Math.random());
		} else if(chSyMoveMode=="valuerandom") {
			cl.setSlantMove(0, chSyMove*Math.random()*(Math.random()>0.5?1:-1));
		} else if(chSyMoveMode=="value") {
			cl.setSlantMove(0, (int)chSyMove);
		}
		cy = _cy;
		return cy;
	}

	function set_chSR(cl_) {
		if(chSlant!=0) {	// ランダムゆらぎ
			cl_.setSlant(
				int(Math.random() *chSlant* (Math.random()>0.5?1:-1)), 
				int(Math.random() *chSlant* (Math.random()>0.5?1:-1))
			);
		}

		if(chSxMode=="none" && chSx!=0) {
			cl_.setSlant( int(Math.random() *chSx* (Math.random()>0.5?1:-1)), 0 );
		}
		if(chSyMode=="none" && chSy!=0) {
			cl_.setSlant( 0, int(Math.random() *chSy* (Math.random()>0.5?1:-1)) );
		}

		if(chRotMode=="none" && chRot!=0) {	// ランダム回転
			cl_.setRad( int(Math.random() * chRot * (Math.random()>0.5?1:-1)) );
		}

		if(chRotMode=="sin") {	// 周期的サインカーブ (0〜chRot)
			cl_.setRad( chRot*Math.sin(1.5707*chRotLoopC/chRotRound) );
			if(chRotLoopC<chRotRound-1) { chRotLoopC++; } else { chRotLoopC=0; }
		} else if(chRotMode=="sinloop") {	// 周期的サインカーブ (0〜chRot〜0〜-chRot〜0)
			cl_.setRad( chRot*Math.sin(6.2831*chRotLoopC/chRotRound) );
			if(chRotLoopC<chRotRound-1) { chRotLoopC++; } else { chRotLoopC=0; }
		}

	// 出現
		if(chRotMoveMode=="random") {
			cl_.setRadMove( int(chRotMoveRound*Math.random()) );
		} else if(chRotMoveMode=="valuerandom") {
			cl_.setRadMove( int(chRotMoveRound*Math.random()*(Math.random()>0.5?1:-1)) );
		} else if(chRotMoveMode=="value") {
			cl_.setRadMove( int(chRotMoveRound) );
		}
	}

/*--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-
/ @スタイル設定追加・セーブロード部分
/=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--*/
	function resetFont() {
		edgeExtent	=	defaultEdgeExtent;
		edgeEmphasis	=	defaultEdgeEmphasis;
		shadowOffsetX	=	defaultShadowOffsetX;
		shadowOffsetY	=	defaultShadowOffsetY;
		r_UserFace		=	r_DefaultFace;
		r_Bold			=	r_DefaultBold;
		r_ShadowColor	=	r_DefaultShadowColor;
		r_EdgeColor		=	r_DefaultEdgeColor;
		r_ChColor		=	r_DefaultChColor;
		rubyAlign		=	defaultRubyAlign;
		rubyOverflow	=	defaultRubyOverflow;
		hchCorrect		=	defaultHchCorrect;

		super.resetFont();
	}

	function setFont(elm) {
		if(elm.edgeextent == 'default')		edgeExtent = defaultEdgeExtent;
		else if(elm.edgeextent !== void)	edgeExtent = +elm.edgeextent;

		if(elm.edgeemphasis == 'default')	edgeEmphasis	=	defaultEdgeEmphasis;
		else if(elm.edgeemphasis !== void)	edgeEmphasis = +elm.edgeemphasis;

		if(elm.shadowoffsetx == 'default')	shadowOffsetX	=	defaultShadowOffsetX;
		else if(elm.shadowoffsetx !== void)	shadowOffsetX = +elm.shadowoffsetx;

		if(elm.shadowoffsety == 'default')	shadowOffsetY	=	defaultShadowOffsetY;
		else if(elm.shadowoffsety !== void)	shadowOffsetY = +elm.shadowoffsety;

		if(elm.rubyconfig) {
			if(elm.rubyface == 'default')		r_UserFace = r_DefaultFace;
			else if(elm.rubyface !== void)		r_UserFace = elm.rubyface;
			if(elm.rbold == 'default')			r_Bold = r_DefaultBold;
			else if(elm.rbold !== void)			r_Bold = elm.rbold;
			if(elm.rshadowcolor == 'default')	r_ShadowColor = r_DefaultShadowColor;
			else if(elm.rshadowcolor !== void)	r_ShadowColor = elm.rshadowcolor;
			if(elm.redgecolor == 'default')		r_EdgeColor = r_DefaultEdgeColor;
			else if(elm.redgecolor !== void)	r_EdgeColor = elm.redgecolor;
			if(elm.rcolor == 'default')			r_ChColor = r_DefaultChColor;
			else if(elm.rcolor !== void)		r_ChColor = elm.rcolor;
		} else {
			r_UserFace = userFace;
			r_Bold = bold;
			r_ChColor = chColor;
			r_ShadowColor = shadowColor;
			r_EdgeColor =edgeColor;
		}

		if(elm.rubyalign == 'default')		rubyAlign = defaultRubyAlign;
		else if(elm.rubyalign !== void)		rubyAlign = elm.rubyalign;

		if(elm.rubyoverflow == 'default')	rubyOverflow = defaultRubyOverflow;
		else if(elm.rubyoverflow !== void)	rubyOverflow = elm.rubyoverflow;

		if(elm.hchcorrect == 'default')		hchCorrect = defaultHchCorrect;
		else if(elm.hchcorrect !== void)	hchCorrect = +elm.hchcorrect;

		super.setFont(elm);
	}

	function setDefaultFont(elm) {
		super.setDefaultFont(elm);

		// デフォルトフォントの設定
		defaultEdgeExtent = +elm.edgeextent if elm.edgeextent !== void;
		defaultEdgeEmphasis = +elm.edgeemphasis if elm.edgeemphasis !== void;
		defaultShadowOffsetX = +elm.shadowoffsetx if elm.shadowoffsetx !== void;
		defaultShadowOffsetY = +elm.shadowoffsety if elm.shadowoffsety !== void;
		defaultRubyAlign = elm.rubyalign if elm.rubyalign !== void;
		defaultRubyOverflow = elm.rubyoverflow if elm.rubyoverflow !== void;
		defaultHchCorrect = +elm.hchcorrect if elm.hchcorrect !== void;

		if(elm.rubyconfig) {
			r_DefaultFace = elm.rubyface if elm.rubyface !== void;
			r_DefaultBold = +elm.rbold if elm.rbold !== void;
			r_DefaultChColor = +elm.rcolor if elm.rcolor !== void;
			r_DefaultShadowColor = +elm.rshadowcolor if elm.rshadowcolor !== void;
			r_DefaultEdgeColor = +elm.redgecolor if elm.redgecolor !== void;
		} else {
			r_DefaultFace = defaultFace;
			r_DefaultBold = defaultBold;
			r_DefaultChColor = defaultChColor;
			r_DefaultShadowColor = defaultShadowColor;
			r_DefaultEdgeColor =defaultEdgeColor;
		}
	}

	function setStyle(elm) {
		super.setStyle(elm);

		ch4Fade = elm.fade if elm.fade !== void;
		chfadetime = +elm.fadetime if elm.fadetime !== void;

		chSlant = +elm.slant if elm.slant!==void;
		chRot = +elm.rot if elm.rot!==void;
	// grad
		chGradMode = elm.gradmode if elm.gradmode !== void;
		chGradLoopC = 0 if elm.gradmode !== void;	// リセット
		chGradation = elm.gradation if elm.gradation !== void;
		chGradationArray = [];
		chGradRound = +elm.gradround if elm.gradround !== void;
	// sx
		chSxMode = elm.slantxmode if elm.slantxmode !== void;
		chSxLoopC = 0 if elm.slantxmode !== void;	// リセット
		chSx = +elm.slantx if elm.slantx !== void;
		chSxRound = +elm.slantxround if elm.slantxround !== void;
	// sy
		chSyMode = elm.slantymode if elm.slantymode !== void;
		chSyLoopC = 0 if elm.slantymode !== void;	// リセット
		chSy = +elm.slanty if elm.slanty !== void;
		chSyRound = +elm.slantyround if elm.slantyround !== void;

		chRotMode = elm.rotmode if elm.rotmode !== void;
		chRotLoopC = 0 if elm.rotmode !== void;;			// 強制リセット
		chRotRound = +elm.rotround if elm.rotround !== void;

	// 回転しながら出現
		chRotMoveMode = elm.rotmovemode if elm.rotmovemode !== void;
		chRotMoveRound = elm.rotmoveround if elm.rotmoveround !== void;
	// ふらふらしながら出現 x y
		chSxMoveMode = elm.sxmovemode if elm.sxmovemode !== void;
		chSxMove = +elm.sxmove if elm.sxmove !== void;
		chSyMoveMode = elm.symovemode if elm.symovemode !== void;
		chSyMove = +elm.symove if elm.symove !== void;
	}

	function setDefaultStyle(elm) {
		super.setDefaultStyle(elm);

		// デフォルトのスタイルの設定
		// オプション設定なので「書かなかったら無し」
		// ただし keepaddition が指定されてると、上書きしない限り前回指定したものをそのまま使う
		defaultCh4Fade = elm.fade if elm.fade !== void;
		defaultChfadetime = +elm.fadetime if elm.fadetime !== void;

		defaultChSlant = elm.slant !== void ? +elm.slant
			 : (elm.keepaddition ? defaultChSlant : 0);
		defaultChRot = elm.rot !== void ? +elm.rot
			 : (elm.keepaddition ?  defaultChRot: 0);
	// grad
		defaultChGradMode = elm.gradmode !== void ? 
			elm.gradmode : (elm.keepaddition ? defaultChGradMode : "none");
		defaultChGradation = elm.gradation !== void ? 
			elm.gradation : (elm.keepaddition ? defaultChGradation : void);
		defaultChGradRound = elm.gradround !== void ? 
			+elm.gradround : (elm.keepaddition ? defaultChGradRound : void);
		defaultChGradLoopC = 0;			// 強制リセット
		defaultChGradationArray = [];	// 強制リセット

		defaultChSxMode = elm.slantxmode !== void ? 
			elm.slantxmode : (elm.keepaddition ? defaultChSxMode : "none");
		defaultChSxLoopC = 0;			// 強制リセット
		defaultChSx = elm.slantx !== void ? 
			+elm.slantx : (elm.keepaddition ? defaultChSx : void);
		defaultChSxRound = +elm.slantxround !== void ? 
			+elm.slantxround : (elm.keepaddition ? defaultChSxRound : void);

		defaultChSyMode = elm.slantymode !== void ? 
			elm.slantymode : (elm.keepaddition ? defaultChSyMode : "none");
		defaultChSyLoopC = 0;			// 強制リセット
		defaultChSy = elm.slanty !== void ? 
			+elm.slanty : (elm.keepaddition ? defaultChSy : void);
		defaultChSyRound = +elm.slantyround !== void ? 
			+elm.slantyround : (elm.keepaddition ? defaultChSyRound : void);

		defaultChRotMode = elm.rotmode !== void ? 
			elm.rotmode : (elm.keepaddition ? defaultChRotMode : "none");
		defaultChRotLoopC = 0;			// 強制リセット
		defaultChRotRound = +elm.rotround !== void ? 
			+elm.rotround : (elm.keepaddition ? defaultChRotRound : void);

		// 回転しながら出現
		defaultChRotMoveMode = elm.rotmovemode !== void ? 
			elm.rotmovemode : (elm.keepaddition ? defaultChRotMoveMode : "none");
		defaultChRotMoveRound = elm.rotmoveround !== void ? 
			+elm.rotmoveround : (elm.keepaddition ? defaultChRotMoveRound : void);
		// ふらふらしながら出現 x y
		defaultChSxMoveMode = elm.sxmovemode !== void ? 
			elm.sxmovemode : (elm.keepaddition ? defaultChSxMoveMode : "none");
		defaultChSxMove = elm.sxmove !== void ? 
			+elm.sxmove : (elm.keepaddition ? defaultChSxMove : void);
		defaultChSyMoveMode = elm.symovemode !== void ? 
			elm.symovemode : (elm.keepaddition ? defaultChSyMoveMode : "none");
		defaultChSyMove = elm.symove !== void ? 
			+elm.symove : (elm.keepaddition ? defaultChSyMove : void);
	}

	function resetStyle() {
		super.resetStyle();

		// スタイルのリセット
		ch4Fade = defaultCh4Fade;
		chfadetime = defaultChfadetime;

		chSlant = defaultChSlant;
		chRot = defaultChRot;
		chGradMode = defaultChGradMode;
		chGradLoopC = defaultChGradLoopC;
		chGradation  = defaultChGradation;
		chGradationArray  = defaultChGradationArray;
		chGradRound = defaultChGradRound;

		chSxMode = defaultChSxMode;
		chSxLoopC = defaultChSxLoopC;
		chSx = defaultChSx;
		chSxRound = defaultChSxRound;

		chSyMode = defaultChSyMode;
		chSyLoopC = defaultChSyLoopC;
		chSy = defaultChSy;
		chSyRound = defaultChSyRound;

		chRotMode = defaultChRotMode;
		chRotLoopC = defaultChRotLoopC;
		chRotRound = defaultChRotRound;

		chRotMoveMode = defaultChRotMoveMode;
		chRotMoveRound = defaultChRotMoveRound;

		chSxMoveMode = defaultChSxMoveMode;
		chSxMove = defaultChSxMove;
		chSyMoveMode = defaultChSyMoveMode;
		chSyMove = defaultChSyMove;
	}

	function internalAssign(src, copyvisiblestate) {
		super.internalAssign(...);

		defaultCh4Fade = src.defaultCh4Fade;			ch4Fade = src.ch4Fade;
		defaultChfadetime = src.defaultChfadetime;	chfadetime = src.chfadetime;

		defaultChSlant = src.defaultChSlant;		chSlant = src.chSlant;
		defaultChRot = src.defaultChRot;		chRot = src.chRot;

		hchCorrect = src.hchCorrect; defaultHchCorrect = src.defaultHchCorrect;

		defaultChGradMode = src.defaultChGradMode;		chGradMode = src.chGradMode;
		defaultChGradLoopC = src.defaultChGradLoopC;	chGradLoopC = src.chGradLoopC;
		defaultChGradation = src.defaultChGradation;	chGradation = src.chGradation;
		defaultChGradationArray = src.defaultChGradationArray;	chGradationArray = src.chGradationArray;
		defaultChGradRound = src.defaultChGradRound;	chGradRound = src.chGradRound;

		defaultChSxMode = src.defaultChSxMode;		chSxMode = src.chSxMode;
		defaultChSxLoopC = src.defaultChSxLoopC;	chSxLoopC = src.chSxLoopC;
		defaultChSx = src.defaultChSx;			chSx = src.chSx;
		defaultChSxRound = src.defaultChSxRound;	chSxRound = src.chSxRound;

		defaultChSyMode = src.defaultChSyMode;		chSyMode = src.chSyMode;
		defaultChSyLoopC = src.defaultChSyLoopC;	chSyLoopC = src.chSyLoopC;
		defaultChSy = src.defaultChSy;		chSy = src.chSy;
		defaultChSyRound = src.defaultChSyRound;	chSyRound = src.chSyRound;

		defaultChRotMode = src.defaultChRotMode;		chRotMode = src.chRotMode;
		defaultChRotLoopC = src.defaultChRotLoopC;	chRotLoopC = src.chRotLoopC;
		defaultChRotRound = src.defaultChRotRound;	chRotRound = src.chRotRound;

		defaultChRotMoveMode = src.defaultChRotMoveMode;		chRotMoveMode = src.chRotMoveMode;
		defaultChRotMoveRound = src.defaultChRotMoveRound;	chRotMoveRound = src.chRotMoveRound;

		defaultChSxMoveMode = src.defaultChSxMoveMode;	chSxMoveMode = src.chSxMoveMode;
		defaultChSxMove = src.defaultChSxMove;		chSxMove = src.chSxMove;
		defaultChSyMoveMode = src.defaultChSyMoveMode;		chSyMoveMode = src.chSyMoveMode;
		defaultChSyMove = src.defaultChSyMove;	chSyMove = src.chSyMove;

		edgeExtent = src.edgeExtent;		defaultEdgeExtent = src.defaultEdgeExtent;
		edgeEmphasis = src.edgeEmphasis;	defaultEdgeEmphasis = src.defaultEdgeEmphasis;
		shadowOffsetX = src.shadowOffsetX;	defaultShadowOffsetX = src.defaultShadowOffsetX;
		shadowOffsetY = src.shadowOffsetY;	defaultShadowOffsetY = src.defaultShadowOffsetY;

		r_UserFace = src.r_UserFace;	r_DefaultFace = src.r_DefaultFace;
		r_Bold = src.r_Bold;	r_DefaultBold = src.r_DefaultBold;
		r_ShadowColor = src.r_ShadowColor;	r_DefaultShadowColor = src.r_DefaultShadowColor;
		r_EdgeColor = src.r_EdgeColor;	r_DefaultEdgeColor = src.r_DefaultEdgeColor;
		r_ChColor = src.r_ChColor;	r_DefaultChColor = src.r_DefaultChColor;

		rubyAlign = src.rubyAlign;	defaultRubyAlign = src.defaultRubyAlign;
		rubyOverflow = src.rubyOverflow;	defaultRubyOverflow = src.defaultRubyOverflow;
	}

	function store() {
		var dic = super.store();

		dic.ch4Fade = ch4Fade;				dic.defaultCh4Fade = defaultCh4Fade;
		dic.chfadetime = chfadetime;		dic.defaultChfadetime = defaultChfadetime;
		dic.hchCorrect = hchCorrect;		dic.defaultHchCorrect = defaultHchCorrect;

		dic.frameGraphic = frameGraphic;

		dic.defaultChSlant = defaultChSlant;		dic.chSlant = chSlant;
		dic.defaultChRot = defaultChRot;		dic.chRot = chRot;

		dic.defaultChGradMode = defaultChGradMode;		dic.chGradMode = chGradMode;
		dic.defaultChGradLoopC = defaultChGradLoopC;	dic.chGradLoopC = chGradLoopC;
		dic.defaultChGradation = defaultChGradation;	dic.chGradation = chGradation;
		dic.defaultChGradRound = defaultChGradRound;	dic.chGradRound = chGradRound;

		dic.defaultChSxMode = defaultChSxMode;		dic.chSxMode = chSxMode;
		dic.defaultChSxLoopC = defaultChSxLoopC;	dic.chSxLoopC = chSxLoopC;
		dic.defaultChSx = defaultChSx;		dic.chSx = chSx;
		dic.defaultChSxRound = defaultChSxRound;	dic.chSxRound = chSxRound;

		dic.defaultChSyMode = defaultChSyMode;		dic.chSyMode = chSyMode;
		dic.defaultChSyLoopC = defaultChSyLoopC;	dic.chSyLoopC = chSyLoopC;
		dic.defaultChSy = defaultChSy;		dic.chSy = chSy;
		dic.defaultChSyRound = defaultChSyRound;	dic.chSyRound = chSyRound;

		dic.defaultChRotMode = defaultChRotMode;		dic.chRotMode = chRotMode;
		dic.defaultChRotLoopC = defaultChRotLoopC;	dic.chRotLoopC = chRotLoopC;
		dic.defaultChRotRound = defaultChRotRound;	dic.chRotRound = chRotRound;

		dic.defaultChRotMoveMode = defaultChRotMoveMode;	dic.chRotMoveMode = chRotMoveMode;
		dic.defaultChRotMoveRound = defaultChRotMoveRound;	dic.chRotMoveRound = chRotMoveRound;

		dic.defaultChSxMoveMode = defaultChSxMoveMode;	dic.chSxMoveMode = chSxMoveMode;
		dic.defaultChSxMove = defaultChSxMove;		dic.chSxMove = chSxMove;
		dic.defaultChSyMoveMode = defaultChSyMoveMode;		dic.chSyMoveMode = chSyMoveMode;
		dic.defaultChSyMove = defaultChSyMove;	dic.chSyMove = chSyMove;

		dic.edgeExtent = edgeExtent;		dic.defaultEdgeExtent = defaultEdgeExtent;
		dic.edgeEmphasis = edgeEmphasis;	dic.defaultEdgeEmphasis = defaultEdgeEmphasis;
		dic.shadowOffsetX = shadowOffsetX;	dic.defaultShadowOffsetX = defaultShadowOffsetX;
		dic.shadowOffsetY = shadowOffsetY;	dic.defaultShadowOffsetY = defaultShadowOffsetY;

		dic.r_UserFace = r_UserFace;	dic.r_DefaultFace = r_DefaultFace;
		dic.r_Bold = r_Bold;	dic.r_DefaultBold = r_DefaultBold;
		dic.r_ShadowColor = r_ShadowColor;	dic.r_DefaultShadowColor = r_DefaultShadowColor;
		dic.r_EdgeColor = r_EdgeColor;	dic.r_DefaultEdgeColor = r_DefaultEdgeColor;
		dic.r_ChColor = r_ChColor;	dic.r_DefaultChColor = r_DefaultChColor;

		dic.rubyAlign = rubyAlign;	dic.defaultRubyAlign = defaultRubyAlign;
		dic.rubyOverflow = rubyOverflow;	dic.defaultRubyOverflow = defaultRubyOverflow;
		return dic;
	}

	function restore(dic) {
		super.restore(dic);

		defaultCh4Fade = dic.defaultCh4Fade if dic.defaultCh4Fade !== void;
		ch4Fade = dic.ch4Fade if dic.ch4Fade !== void;
		defaultChfadetime = dic.defaultChfadetime if dic.defaultChfadetime !== void;
		chfadetime = dic.chfadetime if dic.chfadetime !== void;
		hchCorrect = dic.hchCorrect if dic.hchCorrect !== void;
		defaultHchCorrect = dic.defaultHchCorrect if dic.defaultHchCorrect !== void;

		defaultChSlant = dic.defaultChSlant if dic.defaultChSlant !== void;
		chSlant = dic.chSlant if  dic.chSlant !== void;
		defaultChRot = dic.defaultChRot if dic.defaultChRot !== void;
		chRot = dic.chRot if dic.chRot !== void;

		defaultChGradMode = dic.defaultChGradMode if dic.defaultChGradMode !== void;
		chGradMode = dic.chGradMode if dic.chGradMode !== void;
		defaultChGradLoopC = dic.defaultChGradLoopC if dic.defaultChGradLoopC !== void;
		chGradLoopC = dic.chGradLoopC if dic.chGradLoopC !== void;
		defaultChGradation = dic.defaultChGradation if dic.defaultChGradation !== void;
		chGradation = dic.chGradation if dic.chGradation !== void;
		defaultChGradRound = dic.defaultChGradRound if dic.defaultChGradRound !== void;
		chGradRound = dic.chGradRound if dic.chGradRound !== void;

		defaultChSxMode = dic.defaultChSxMode if dic.defaultChSxMode !== void;
		chSxMode = dic.chSxMode if dic.chSxMode !== void;
		defaultChSxLoopC = dic.defaultChSxLoopC if dic.defaultChSxLoopC !== void;
		chSxLoopC = dic.chSxLoopC if dic.chSxLoopC !== void;
		defaultChSx = dic.defaultChSx if dic.defaultChSx !== void;
		chSx = dic.chSx if dic.chSx !== void;
		defaultChSxRound = dic.defaultChSxRound if dic.defaultChSxRound !== void;
		chSxRound = dic.chSxRound if dic.chSxRound !== void;

		defaultChSyMode = dic.defaultChSyMode if dic.defaultChSyMode !== void;
		chSyMode = dic.chSyMode if dic.chSyMode !== void;
		defaultChSyLoopC = dic.defaultChSyLoopC if dic.defaultChSyLoopC !== void;
		chSyLoopC = dic.chSyLoopC if dic.chSyLoopC !== void;
		defaultChSy = dic.defaultChSy if dic.defaultChSy !== void;
		chSy = dic.chSy if dic.chSy !== void;
		defaultChSyRound = dic.defaultChSyRound if dic.defaultChSyRound !== void;
		chSyRound = dic.chSyRound if dic.chSyRound !== void;

		defaultChRotMode = dic.defaultChRotMode if dic.defaultChRotMode !== void;
		chRotMode = dic.chRotMode if dic.chRotMode !== void;
		defaultChRotLoopC = dic.defaultChRotLoopC if dic.defaultChRotLoopC !== void;
		chRotLoopC = dic.chRotLoopC if dic.chRotLoopC !== void;
		defaultChRotRound = dic.defaultChRotRound if dic.defaultChRotRound !== void;
		chRotRound = dic.chRotRound if dic.chRotRound !== void;

		defaultChRotMoveMode = dic.defaultChRotMoveMode if dic.defaultChRotMoveMode !== void;
		chRotMoveMode = dic.chRotMoveMode if dic.chRotMoveMode !== void;
		defaultChRotMoveRound = dic.defaultChRotMoveRound if dic.defaultChRotMoveRound !== void;
		chRotMoveRound = dic.chRotMoveRound if dic.chRotMoveRound !== void;

		defaultChSxMoveMode = dic.defaultChSxMoveMode if dic.defaultChSxMoveMode !== void;
		chSxMoveMode = dic.chSxMoveMode if dic.chSxMoveMode !== void;
		defaultChSxMove = dic.defaultChSxMove if dic.defaultChSxMove !== void;
		chSxMove = dic.chSxMove if dic.chSxMove !== void;
		defaultChSyMoveMode = dic.defaultChSyMoveMode if dic.defaultChSyMoveMode !== void;
		chSyMoveMode = dic.chSyMoveMode if dic.chSyMoveMode !== void;
		defaultChSyMove = dic.defaultChSyMove if dic.defaultChSyMove !== void;
		chSyMove = dic.chSyMove if dic.chSyMove !== void;

		edgeExtent = dic.edgeExtent;		defaultEdgeExtent = dic.defaultEdgeExtent;
		edgeEmphasis = dic.edgeEmphasis;	defaultEdgeEmphasis = dic.defaultEdgeEmphasis;
		shadowOffsetX = dic.shadowOffsetX;	defaultShadowOffsetX = dic.defaultShadowOffsetX;
		shadowOffsetY = dic.shadowOffsetY;	defaultShadowOffsetY = dic.defaultShadowOffsetY;

		r_UserFace = dic.r_UserFace;	r_DefaultFace = dic.r_DefaultFace;
		r_Bold = dic.r_Bold;	r_DefaultBold = dic.r_DefaultBold;
		r_ShadowColor = dic.r_ShadowColor;	r_DefaultShadowColor = dic.r_DefaultShadowColor;
		r_EdgeColor = dic.r_EdgeColor;	r_DefaultEdgeColor = dic.r_DefaultEdgeColor;
		r_ChColor = dic.r_ChColor;	r_DefaultChColor = dic.r_DefaultChColor;

		rubyAlign = dic.rubyAlign;	defaultRubyAlign = dic.defaultRubyAlign;
		rubyOverflow = dic.rubyOverflow;	defaultRubyOverflow = dic.defaultRubyOverflow;
	}

/*--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-
/ @サブルーチン
/=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--*/
/*-----------------------------------------------------------------------------
/ @	任意色間グラデーション用配列を生成する
/		16進数6桁のカラーを引数([c1, c2, c3...])にとり、
/		長さnの任意色間グラデーション配列を生成し、配列pに格納する
/
/ ここのソースを元にしましたぜ
/ http://www.graviness.com/virgo/javascript/d011211.html
/----------------------------------------------------------------------------*/
function gradationX( c, n, p ) {
	var s = c.count-1;
	if(s==1) {
		// 2値なら普通に返す
		// 3値もよく使われるらしいが、専用に作ってもそんな速度変わらんかった
		return gradation2side( c[0], c[1], n, p );
	} else {
		var m = Math.floor( n/s );	// 各rex要素の長さ。切り捨て
		var q = ( n-m*s )/s;		// 切り捨てで出た誤差の1グラデ当りの量
		var k = 0;					// 誤差修正用

		for(var i=0;i<s;i++) {
		// 最終グラデ以外は予め1伸ばし、i番目の最後とi+1番目の最初の色が重複する
		// ので生成後に削除する。
			var m2 = (i==s-1)?m:m+1;	// 最終グラデ以外は1伸ばし
		// 誤差を足していき、1を超えたらその2値のグラデは1伸ばす
			if( (k+=q) >= 1 ) { --k; ++m2; }
			gradation2side( c[i], c[i+1], m2, p );
			if(i<s-1) p.erase(-1);	// ケツは重複するので削除
		}

		return p;
	}
}

/*-----------------------------------------------------------------------------
/ @	2色間グラデーション用配列を生成する
/		16進数6桁のカラーを引数(p0,p1)にとり
/		長さnの2色間グラデーション配列を生成してpに入れる
/ 泥い方法で少しだけ速く
/----------------------------------------------------------------------------*/
function gradation2side( p0, p1, n, p ) {
	var c0=[] = toRGB(p0), c1=[] = toRGB(p1), dcr, dcg, dcb;
	var pc = p.count;

	dcr = (c1[0]-c0[0])/(n-1);	// RGBオフセット計算
	dcg = (c1[1]-c0[1])/(n-1);
	dcb = (c1[2]-c0[2])/(n-1);
	// オフセット加算しつつ16進数6桁に再生成
	p[pc++] = ( ((c0[0])<<16)|((c0[1])<<8)|(c0[2]) );	// 1発目オフセ無し
	while(--n)
		p[pc++] = ( ((c0[0]+=dcr)<<16)|((c0[1]+=dcg)<<8)|(c0[2]+=dcb) );
	return p;
}

/*-----------------------------------------------------------------------------
/ @	0xFFFFFF が連なった文字列を配列にする
/		デミリタは , 
/		すでに数字、配列になっているものはそのまま返す(はず)
/----------------------------------------------------------------------------*/
function parseColor2Array(color) {
	var res = color!==void	? color	: 0x000000;
	if(typeof res==="String" && res.indexOf(",")!==-1)
		return res.split(",", ,true);

	return res;
}

/*-----------------------------------------------------------------------------
/ @	前 -> 後ろの順で選択する	Ver.0.10
/	i に値があるなら i、無いなら els を返す
/----------------------------------------------------------------------------*/
function autoSelect(i, els) {
	return i!==void ? i : els;
}
}

/*--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-
/  ChGrad用RectorPlugin
/=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=- */

var ChGradRecter_object;

try {
	Scripts.execStorage("RecterPlugin.tjs");
	dm("MessageLayerADV : RecterPluginを読み込みました");
} catch(e) {
	dm("MessageLayerADV : RecterPluginは見つかりませんでした");
}

if(Plugins.getList().find("util_graph.dll") != -1) {

dm("MessageLayerADV : RecterPluginとutil_graph.dllが見つかりました。ChGradRecterを初期化します");
__flag_ChGradRecter_OBJECT_DEFINED__ = 1;
class ChGradRecter extends RecterPlugin {
	var doChGrad = false;

	// 描画条件比較用パラメータ
	var comp_param = %[];

	// 描画設定集 FadeChLayerから参照される
	var base_param_arr = new Array();	// 基本セッティングクロール用配列
	var method;
	var ch = true;	// 文字をグラデる
	var ruby = false;	// ルビをグラデる
	var edge = false;	// エッジをグラデる
	var withRuby = false;	// ルビは独立してグラデる
	var withEdge = false;	// エッジもグラデる
	var eachCh = true;	// 1文字1文字グラデる

	var def_base_param_arr = new Array();
	var def_method = "Rect";
	var def_ch = false;		// デフォルト
	var def_ruby = false;
	var def_edge = false;
	var def_withRuby = false;
	var def_withEdge = false;
	var def_eachCh = true;

	function ChGradRecter(window, plgName) {
		super.RecterPlugin(...);
	//	neutralColor = 0x00FFFFFF;
	}

	function finalize() {
		super.finalize(...);
	}

	/*
	/ ch		文字をグラデる
	/ edge		エッジをグラデる
	/ 
	/ 以下、普段は指定しないでよい要素
	/ ruby		ルビをグラデる
	/			chまたはedgeが指定されたとき、デフォルトでtrue
	/ withRuby	本文とルビを合わせて一つのグラデーションでグラデる
	/			デフォルトでfalse
	/ withEdge	エッジ部分までグラデーションの領域を拡張する
	/			デフォルトはedge指定と同じ値
	/ eachCh	chタグやrubyタグで複数文字を指定したときに、1文字ずつグラデる
	/			デフォルトでtrue
	*/
	function setChGrad(elm) {
		comp_param = %[];

		base_param_arr.assign(elm);
		method = elm.method!==void ? elm.method : def_method;

		ch = elm.ch!==void ? elm.ch : def_ch;
		edge = elm.edge!==void ? elm.edge : def_edge;
		ruby = elm.ruby!==void ? elm.ruby : def_ruby;
		withRuby = elm.withruby!==void ? elm.withruby : def_withRuby;
		withEdge = elm.withedge!==void ? elm.withedge : def_withEdge;
		eachCh = elm.eachch!==void ? elm.eachch : def_eachCh;

		doChGrad = (ch || edge || ruby);
	}

	function setDefaultChGrad(elm) {
		comp_param = %[];

		def_base_param_arr.assign(elm);
		def_method = elm.method if elm.method !== void;

		def_ch = elm.ch if elm.ch!==void;
		def_edge = elm.edge if elm.edge!==void;
		def_ruby = elm.ruby if elm.ruby!==void;
		def_withRuby = elm.withruby if elm.withruby!==void;
		def_withEdge = elm.withedge if elm.withedge!==void;
		def_eachCh = elm.eachch if elm.eachch!==void;

		// ルビグラデが無いときはルビ込みも無効になる
		if(!def_ruby) { def_withRuby = false; }
		// edgeグラデが有効で、かつwithedge指定がないとき、withedgeが有効になる
		if(def_edge && elm.withedge===void) { def_withEdge = true; }
		// chかedgeグラデが有効で、かつruby指定がないとき、rubyが有効になる
		if((def_ch || def_edge) && elm.ruby===void) { def_ruby = true; }
	}

	function resetChGrad() {
		base_param_arr.assign(def_base_param_arr);
		method = def_method;

		ch = def_ch;
		edge = def_edge;
		ruby = def_ruby;
		withRuby = def_withRuby;
		withEdge = def_withEdge;
		eachCh = def_eachCh;

		doChGrad = (ch || edge || ruby);
	}

	function assign(src) {
		base_param_arr.assign(src.base_param_arr);
		method = src.method;
		ch = src.ch;
		edge = src.edge;
		ruby = src.ruby;
		withRuby = src.withRuby;
		withEdge = src.withEdge;
		eachCh = src.eachCh;

		def_base_param_arr.assign(src.def_base_param_arr);
		def_method = src.def_method;
		def_ch = src.def_ch;
		def_edge = src.def_edge;
		def_ruby = src.def_ruby;
		def_withRuby = src.def_withRuby;
		def_withEdge = src.def_withEdge;
		def_eachCh = src.def_eachCh;

		doChGrad = src.doChGrad;
	}

	function finishChGrad(elm) {
		doChGrad = false;
		finish();
		stop();
	}

	function set(elm) {
	// 前回と描画条件が変わっていた場合のみ再描画を行う
		var redraw = false;

		var bpc = base_param_arr.count;
		while (bpc) {
			bpc-=2;
			elm[base_param_arr[bpc]] = base_param_arr[bpc+1];
		}

		with(comp_param) {
			redraw = (.width==elm.width && .height==elm.height
				 && .x==elm.x && .y==elm.y && .w==elm.w && .h==elm.h
				) ? redraw : true;

			switch(method) {
				case 'Rect':
			//		redraw = (.recttype===elm.recttype && .dir===elm.dir) ? redraw : true;
				break;
				case 'Circle':
					redraw = (.r===elm.r) ? redraw : true;
				break;
				case 'Ellipse':
					redraw = (.ra===elm.ra && .rb===elm.rb) ? redraw : true;
				break;
				case 'Triangle':
					redraw = (
						.x1===elm.x1 && .x2===elm.x2 && .x3===elm.x3
					 && .y1===elm.y1 && .y2===elm.y2 && .y3===elm.y3
					) ? redraw : true;
				break;
				case 'RoundRect':
					redraw = (.r == elm.r) ? redraw : true;
				break;
				default:
				break;
			}
		}

		if(redraw) {
			(Dictionary.assign incontextof comp_param)(elm);	// 条件コピー
			elm.absolute = 1;
			elm.hide = true;
			super.set(elm);
			showLayer.visible = false;
			transLayer.visible = false;
		}
	}

	function onStore(f, elm) {
		super.onStore(...);
		with(f[pluginName]) {
			.doChGrad = doChGrad;

			.base_param_arr = new Array();
			.def_base_param_arr = new Array();

			.base_param_arr.assign(base_param_arr);
			.method = method;
			.ch = ch;
			.edge = edge;
			.ruby = ruby;
			.withRuby = withRuby;
			.withEdge = withEdge;
			.eachCh = eachCh;

			.def_base_param_arr.assign(def_base_param_arr);
			.def_method = def_method;
			.def_ch = def_ch;
			.def_edge = def_edge;
			.def_ruby = def_ruby;
			.def_withRuby = def_withRuby;
			.def_withEdge = def_withEdge;
			.def_eachCh = def_eachCh;
		}
	}

	function onRestore(f, clear, elm) {
		super.onRestore(...);

		if(f[pluginName]===void) return;
 		with(f[pluginName]) {
			if(.doChGrad) {
				doChGrad = .doChGrad;

				base_param_arr = new Array();
				if(.base_param_arr !== void) {
					base_param_arr.assign(.base_param_arr);
				}

				method = .method;
				ch = .ch;
				edge = .edge;
				ruby = .ruby;
				withRuby = .withRuby;
				withEdge = .withEdge;
				eachCh = .eachCh;

				def_base_param_arr = new Array();
				if(.def_base_param_arr !== void) {
					def_base_param_arr.assign(.def_base_param_arr);
				}
				def_method = .def_method;
				def_ch = .def_ch;
				def_edge = .def_edge;
				def_ruby = .def_ruby;
				def_withRuby = .def_withRuby;
				def_withEdge = .def_withEdge;
				def_eachCh = .def_eachCh;
			}
		}
	}
}

kag.tagHandlers.setchgradation = function(elm) {
	if(currentWithBack) current.comp.chGradObj.setChGrad(elm);
	current.chGradObj.setChGrad(elm);
	return 0;
} incontextof kag;

kag.tagHandlers.resetchgradation = function(elm) {
	if(currentWithBack) current.comp.chGradObj.resetChGrad(elm);
	current.chGradObj.resetChGrad(elm);
	return 0;
} incontextof kag;

kag.tagHandlers.stopchgradation = function(elm) {
	if(currentWithBack) current.comp.chGradObj.finishChGrad(elm);
	current.chGradObj.finishChGrad(elm);
	return 0;
} incontextof kag;


kag.tagHandlers.setdefaultchgradation = function(elm) {
	if(currentWithBack) current.comp.chGradObj.setDefaultChGrad(elm);
	current.chGradObj.setDefaultChGrad(elm);
	return 0;
} incontextof kag;

}



/* -----------------------------------------------------------------------------
/  KAG分
/ --------------------------------------------------------------------------- */
/*--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-
/ @拡張メッセージレイヤを作成するようにする
/=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--*/
kag.org_allocateMessageLayers = kag.allocateMessageLayers;
kag.allocateMessageLayers = function(num, setdefaultfont = true) {
	// メッセージレイヤ数を num に設定する
	if(fore.messages.count > num) {
		// レイヤが減る
		for(var i = num; i<fore.messages.count; i++) {
			if(current == fore.messages[i] || current == back.messages[i])
				current = fore.messages[0], currentNum = 0, currentPage = 0;
			invalidate fore.messages[i];
			invalidate back.messages[i];
		}
		fore.messages.count = num;
		back.messages.count = num;
	}
	else if(fore.messages.count < num) {
		// レイヤが増える
		var cnt = fore.messages.count;
		for(var i=cnt; i<num; i++) {
			fore.messages[i] = new MessageLayerADV(this, fore.base, "表メッセージレイヤ" + i, i, true);
			back.messages[i] = new MessageLayerADV(this, back.base, "裏メッセージレイヤ" + i, i, true);
			fore.messages[i].setCompLayer(back.messages[i]);
			back.messages[i].setCompLayer(fore.messages[i]);
			fore.messages[i].clear();
			back.messages[i].clear();
		}
		reorderLayers();
		if(setdefaultfont) setMessageLayerUserFont();
		if(cnt==0) {
			setCurrentMessageLayer(%[page:"fore", layer:"message0"]);
		}
	}
	numMessageLayers = num;
} incontextof kag;

/*--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-
/ @タグ新規作成・オーバーライド
/=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--*/
// @ruby - ルビ振り
kag.tagHandlers.messageLayerADV_org_ruby = kag.tagHandlers.ruby;
kag.tagHandlers.ruby = function(elm) {
	elm.overflow = elm.of if(elm.of!==void);
	if(currentWithBack) current.comp.setRuby(elm.text, elm.align, elm.overflow);
	current.setRuby(elm.text, elm.align, elm.overflow);

	return 0;
} incontextof kag;

// @waitFadeCh - FadeCh終了を待つ
kag.tagHandlers.waitfadech = function(elm) {
	if(current.processChnInF)
		return 0;
	else
		return current.waitFinishCh(elm);
} incontextof kag;

// @finishFadeCh - カレントの、現在プロセス中の Ch を最終状態に持ち込む
kag.tagHandlers.finishfadech = function(elm) {
	return current.forEachFadeChFinish();
} incontextof kag;

kag.processUnKnownTag = function(tagname, elm) {
// ここから直接 tagHandlers にアクセスしても大丈夫。なハズ。
	if((string)tagname.indexOf("r_", 0)==0) {
	// [r_%1_○○]		-	○○部分がルビ指定。%1部分が割り付け指定
		if((string)tagname.indexOf("r_c_", 0)==0) {
			elm.text = (string)tagname.replace(/^r_c_/,);
			elm.align = "c";
		} else if((string)tagname.indexOf("r_r_", 0)==0) {
			elm.text = (string)tagname.replace(/^r_r_/,);
			elm.align = "r";
		} else if((string)tagname.indexOf("r_l_", 0)==0) {
			elm.text = (string)tagname.replace(/^r_l_/,);
			elm.align = "l";
		} else {
			elm.text = (string)tagname.replace(/^r_/,);
		}
		return tagHandlers.ruby(elm);
	} else if((string)tagname.indexOf("ch_", 0)==0) {
	// [ch_○○]		-	○○部分がtext指定
		elm.text = (string)tagname.replace(/^ch_/,);
		return tagHandlers.ch(elm);
	} else if((string)tagname.indexOf("hch_", 0)==0) {
		elm.text = tagname.substring(4);
//		elm.hch = true;
//		elm.expand = true;
		return tagHandlers.hch(elm);
	} else {
		return -1;
	}
} incontextof kag;

kag.messageLayerADV_org_onConductorUnknownTag = kag.onConductorUnknownTag;
kag.onConductorUnknownTag = function(tagname, elm) {
	var n = processUnKnownTag(tagname, elm);
	if(n!==-1) {
		return n;
	} else {
		throw new Exception('タグ/マクロ \''+tagname+'\' は存在しません');
		return 0; // この戻り値は、各タグハンドラが返す物とおなじ
	}
} incontextof kag;

/*--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=-
/ @ MessageLayerをMessageLayerADVに置き換える
/ current が kag.fore.messages[0] に再設定される
/=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--=--*/
if (kag.fore.messages[0] instanceof "MessageLayer") {
	var i = kag.fore.messages.count;
	kag.allocateMessageLayers(0);
	kag.allocateMessageLayers(i);
}

@endif
